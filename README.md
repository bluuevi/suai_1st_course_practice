# Программа, сортирующая слова из текста. Написана в ходе выполнения учебной практики на 1 курсе ГУАП 
----
## Параметры сортировки

+ Латиница  
Работа с символами «abcdefghijklmnopqrstuvwxyz1234567890»
+ По количеству символов в слове   
Необходимо вычислить длину каждого слова и осуществить сортировку относительно этого количества
+ По убыванию   
Слова должны «идти» от большего к меньшему
+ Учитывать числа    
При сортировке числа рассматриваются в качестве отдельных слов, а после в алфавитном порядке выводятся перед словами
+ Быстрая сортировка   
Алгоритм быстрой сортировки из массива произвольным образом выбирает некоторый опорный элемент; запускается процедура разделения массива, которая перемещает все элементы, большие опорного, влево от него, а меньшие - вправо, теперь массив состоит из двух подмножеств, причем элементы левого больше элементов правого. Для обоих подмножеств: если в нем более двух элементов, рекурсивно запускаем для него ту же процедуру. В конце получится полностью отсортированная последовательность
---
## Параметры входных и выходных данных

На вход программа принимает   
+ Путь к файлу с оригиналом текста
+ Путь к файлу для вывода результата
+ Путь к файлу для вывода анализа    
Программа создает файлы результата и анализа по введенным путям   

Файл результата содержит: 
+ Слова из исходного файла отсортированные по количеству символов в слове, по убыванию    
![image](https://user-images.githubusercontent.com/105609667/171738311-2716e053-e019-4031-976a-bb2b35c10ccd.png)   
*Пример файла с результатом*   
Файл с анализом содержит:
+ Исходный текст
+ Параметры варианта
+ Количество слов в тексте
+ Время выполнения программы
+ Количество слов каждой длины, по убыванию

![image](https://user-images.githubusercontent.com/105609667/171738857-c92dd43d-abeb-4867-b499-f51ea3ddd1bf.png)    
*Пример файла с анализом*      
-----
# Описание работы программы   

Программа просит пользователя ввести полный путь к файлу с оригиналом текста. Создает вектор строк, в который позже будут записаны слова. Подает этот вектор и путь к файлу в функцию __input()__, которая проверит файл на открытие, и если что, попросит пользователя ввести путь к файлу повторно. Также, прочитает каждое слово из файла, удалит из него ненужные символы, и запишет это слово в вектор.
```C++
void input(vector<string>& words, string& pathOriginal) 
{                                                     
    ifstream original; //создаем объект класса ifstream
    bool check = false; // для проверки ввода пути
    while (check == false) {
        check = true;
        original.open(pathOriginal); // открываем файл по введенному пути
        if (!original.is_open()) // если не открылся
        {
            cout << "Ошибка доступа к файлу." << endl;
            cout << "Введите полный путь к текстовому файлу" << endl;
            getline(cin, pathOriginal);
            check = false;
        }
    }

    while (!original.eof()) // пока файл не закончится    
    {
        string newWord; //новое слово
        original >> newWord; //записываем новое слово из файла
        newWord = editWord(newWord); //редактируем слово 
        if (newWord.length() > 0) { // если длина слова не 0
            words.push_back(newWord); //записываем слово в вектор со словами
        }
    }
    original.close(); //закрываем файл с оригиналом текста
}
```   

Для редактирования каждого слова и удаления из него лишних символов в функции __input()__ вызывается функция __editWord__
```C++
string editWord(string word) 
{
    for (int i = 0; i < word.length(); i++) //перебираем символы
    {
        if (!(isalnum(word[i]) and word[i] <= 127)) //если не число и не буквы латиницы
        {
            if (word.length() == 1) //если длина слова 1 символ
                word.erase(i); //стираем его
            else { //если больше символов
                word.erase(i, 1); //удаляем символ и все что справа перемещаем левее
                i--; //возвращаемся к тому же месту символа, чтобы проверить следующий
            }
        }
    }
    return word; 
}
```


Далее, алгоритм сортирует вектор. Он берет элемент, находящийся в середине вектора, за опорный. Далее, слева и справа от опорного ищет элементы, которые можно поменять местами. Меняет все возможные пары элементов. Затем, таким же образом сортирует части вектора, получившиеся слева и справа от опорного элемента. Рекурсивная функция повторяется до того момента, пока весь вектор не будет отсортирован. Программа вычисляет время, затраченное на сортировку.
```C++
void qsort(vector <string>& vec, int left, int right) { 
    int i = left, j = right; //левый и правый элементы от которых будем двигаться
    string temp; //временная переменная для перестановки двух элементов местами
    int pivot = vec[(left + right) / 2].length(); //опорный элемент, средний в рассматриваемой части вектора

    while (i <= j) { //пока левый индекс не больше правого
        while (vec[i].length() > pivot) //пока длина рассматриваемого слова слева больше опорного
            i++; //увеличиваем счетчик чтобы посмотреть следующее
        while (vec[j].length() < pivot) // пока длина рассматриваемого слова справа меньше опорного
            j--; //уменьшаем счетчик чтобы посмотреть следующее
        if (i <= j) { //дошли до слов которые можно поменять местами
            temp = vec[i]; //меняем
            vec[i] = vec[j];
            vec[j] = temp;
            i++; //переходим к следующим
            j--;
        }
    };

    if (left < j) // пока есть что сортировать левее от опорного
        qsort(vec, left, j); //сортируем
    if (i < right) //пока есть что сортировать правее от опорного
        qsort(vec, i, right); //сортируем

}
```    
Программа просит пользователя ввести путь к файлу для результата. Подает путь и отсортированный вектор слов в функцию __result()__, в которой выводит слова в текстовый файл.
```C++
void result(vector<string>& words, string pathResult)
{
    ofstream result; //открываем файл для записи
    bool check = false; // для проверки ввода пути
    while (check == false) {
        check = true;
        result.open(pathResult); // открываем файл по введенному пути
        if (!result.is_open()) // если не открылся
        {
            cout << "Ошибка доступа к файлу." << endl;
            cout << "Введите полный путь к текстовому файлу" << endl;
            getline(cin, pathResult);
            check = false;
        }
    }
 
    for (int i = 0; i < words.size(); i++) // перебираем слова в векторе слов
        result << words[i] << " "; //записываем их в файл для результата
    result.close(); //закрываем файл с результатом
}
```   
Программа просит пользователя ввести путь к файлу для анализа. Подает этот путь, отсортированный вектор слов, время сортировки и путь к файлу с оригинальным текстом в функцию __analysis()__, которая копирует из исходного файла строки до знака переноса и печатает их в выходной файл и консоль, туда же выводит условия варианта, время сортировки, количество слов – размер вектора, все длины слов и количество слов каждой длины.     
```C++
void analysis(vector<string>& words, int time, string pathOriginal, string pathAnalysis)
{
    ifstream original; //оригинальный для чтения
    ofstream analysis; // анализ для записи
    bool check = false; // для проверки ввода пути
    while (check == false) {
        check = true;
        analysis.open(pathAnalysis); // открываем файл по введенному пути
        if (!analysis.is_open()) // если не открылся
        {
            cout << "Ошибка доступа к файлу." << endl;
            cout << "Введите полный путь к текстовому файлу" << endl;
            getline(cin, pathAnalysis);
            check = false;
        }
    }
   
    analysis << "Исходный текст: " << endl;
    cout << "Исходный текст: " << endl;
    original.open(pathOriginal); // открываем файл с оригинальным текстом
    while (!original.eof()) // пока не конец файла
    {
        string line; // строка
        getline(original, line); //считываем строку из файла с ориг текстом
        analysis << line << endl; // записываем в файл анализа
        cout << line << endl;
    }
    original.close(); // закрываем файл с оригинальным текстом

    //выводим в файл анализа и на консоль информацию о варианте задания и тд
    analysis << endl << "Вариант 11: латиница, по количеству символов в слове, по убыванию, учитывать числа, быстрая сортировка." << endl << "Количество слов : " << words.size()
             << endl << "Время сортировки: " << time << " мс" << endl << "Статистика(количество слов каждой длины) :" << endl;

    cout << endl << "Вариант 11: латиница, по количеству символов в слове, по убыванию, учитывать числа, быстрая сортировка." << endl << "Количество слов : " << words.size()
         << endl << "Время сортировки: " << time << " мс" << endl << "Статистика(количество слов каждой длины) :" << endl;

    vector<WordsLengthsCount> wordsLengthsCount; //вектор с длинами и количеством слов каждой длины
    findLengthsCountWords(words, wordsLengthsCount); // ищем длины и считаем слова каждой длины

    for (int i = 0; i < wordsLengthsCount.size();  i++) //перебираем длины по убыванию
    {   //выводим в файл анализа и на консоль каждую длину и количество слов
        analysis << wordsLengthsCount[i].length << " - " << wordsLengthsCount[i].count << endl; 
        cout << wordsLengthsCount[i].length << " - " << wordsLengthsCount[i].count << endl; 
    }
    analysis.close();
}
```  


В процессе выполнения функции анализа программа обращается еще к двум функциям __findLengthsCountWords()__ -- вычисляет количество слов каждой длины.

```C++
void findLengthsCountWords(vector<string>& words, vector<WordsLengthsCount>& wordsLengthsCount)
{
    for (int i = 0; i < words.size(); i++) //перебираем слова
    {
        int finded = findLength(wordsLengthsCount, words[i].length()); //ищем есть ли в уже записанных длинах длина рассматриваемого слова
        if (finded == -1) //если нет
        {
            WordsLengthsCount new_length;  //создаем новую длину
            new_length.length = words[i].length(); //записываем ее
            new_length.count++; //прибавляем счетчик количества слов этой длины
            wordsLengthsCount.push_back(new_length);
        }
        else
        {
            wordsLengthsCount[finded].count++; //прибавляем счетчик количества слов этой длины
        }
    }
}
```
и __findLength()__ -- проверяет, есть ли искомая длина в векторе длин 

```C++
int findLength(vector <WordsLengthsCount> vec, int length) 
{
    for (int i = 0; i < vec.size(); i++)  // перебираем длины
    {
        if (vec[i].length == length) // если есть такая длина
            return i; // возвращаем ее номер
    }
    return -1; // иначе возвращаем -1
}
```   
А также, использует класс __WordsLengthsCount__
```C++

class WordsLengthsCount   
{
public:
    int length = 0; //длина слова
    int count = 0; //количество слов этой длины
};
```

![image](https://user-images.githubusercontent.com/105609667/171742044-3df48331-694a-4b42-a313-036cda221e69.png)

*Пример вывода на консоль*


------
![image](https://user-images.githubusercontent.com/105609667/171809021-2b8c7414-8822-4416-ac96-955bcca72bf9.png)
* А это моя жаба желает Вам хорошего дня!!*



















